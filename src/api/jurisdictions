from fastapi import APIRouter, Query, HTTPException
from typing import Optional, Dict, Any, List
from datetime import datetime

from src.utils.database import prisma

router = APIRouter(prefix="/jurisdictions", tags=["Jurisdictions"])


def _clean(s: Optional[str]) -> Optional[str]:
    if s is None:
        return None
    s = str(s).strip()
    return s if s else None


def _dt(v: Any) -> Any:
    # Keep JSON-friendly timestamps
    if isinstance(v, datetime):
        return v.isoformat()
    return v


def _to_jurisdiction_dict(j: Any) -> Dict[str, Any]:
    # Tight, stable payload
    return {
        "id": getattr(j, "id", None),
        "name": getattr(j, "name", None),
        "code": getattr(j, "code", None),
        "country": getattr(j, "country", None),
        "type": getattr(j, "type", None),
        "description": getattr(j, "description", None),
        "website": getattr(j, "website", None),
        "active": getattr(j, "active", None),
        "contactInfo": getattr(j, "contactInfo", None),
        "createdAt": _dt(getattr(j, "createdAt", None)),
        "updatedAt": _dt(getattr(j, "updatedAt", None)),
    }


def _to_rule_dict(r: Any) -> Dict[str, Any]:
    return {
        "id": getattr(r, "id", None),
        "name": getattr(r, "name", None),
        "active": getattr(r, "active", None),
    }


def _to_production_dict(p: Any) -> Dict[str, Any]:
    return {
        "id": getattr(p, "id", None),
        "name": getattr(p, "name", None),
        "active": getattr(p, "active", None),
    }


@router.get("/")
async def list_jurisdictions(
    q: Optional[str] = Query(None, description="Search (matches name/code/country/type)"),
    country: Optional[str] = Query(None, description="Filter by country (exact match)"),
    type: Optional[str] = Query(None, description="Filter by type (state/province/country/etc.)"),
    active: Optional[bool] = Query(None, description="Filter by active status"),
    limit: int = Query(1000, ge=1, le=5000, description="Max rows to return"),
    offset: int = Query(0, ge=0, description="Pagination offset"),
    order_by: str = Query("code", description="Sort field: code|name|country|type"),
    order_dir: str = Query("asc", description="Sort direction: asc|desc"),
    include_relations: bool = Query(False, description="Include related incentiveRules and productions"),
) -> Dict[str, Any]:
    q = _clean(q)
    country = _clean(country)
    type = _clean(type)

    allowed_order_fields = {"code", "name", "country", "type"}
    if order_by not in allowed_order_fields:
        raise HTTPException(status_code=400, detail=f"Invalid order_by. Allowed: {sorted(allowed_order_fields)}")

    od = order_dir.lower()
    if od not in {"asc", "desc"}:
        raise HTTPException(status_code=400, detail="Invalid order_dir. Use asc or desc.")

    where: Dict[str, Any] = {}
    if country:
        where["country"] = country
    if type:
        where["type"] = type
    if active is not None:
        where["active"] = active
    if q:
        where["OR"] = [
            {"name": {"contains": q, "mode": "insensitive"}},
            {"code": {"contains": q, "mode": "insensitive"}},
            {"country": {"contains": q, "mode": "insensitive"}},
            {"type": {"contains": q, "mode": "insensitive"}},
        ]

    order = [{order_by: od}]

    # total BEFORE pagination
    total = await prisma.jurisdiction.count(where=where)

    find_kwargs: Dict[str, Any] = {
        "where": where,
        "skip": offset,
        "take": limit,
        "order": order,
    }

    if include_relations:
        # Keep relations, but we will still trim them in the response
        find_kwargs["include"] = {"incentiveRules": True, "productions": True}

    rows = await prisma.jurisdiction.find_many(**find_kwargs)

    jurisdictions: List[Dict[str, Any]] = []
    for j in rows:
        item = _to_jurisdiction_dict(j)
        if include_relations:
            rules = getattr(j, "incentiveRules", None) or []
            prods = getattr(j, "productions", None) or []
            item["incentiveRules"] = [_to_rule_dict(r) for r in rules]
            item["productions"] = [_to_production_dict(p) for p in prods]
        jurisdictions.append(item)

    return {
        "total": total,
        "limit": limit,
        "offset": offset,
        "q": q,
        "filters": {"country": country, "type": type, "active": active},
        "order": {"by": order_by, "dir": od},
        "include_relations": include_relations,
        "jurisdictions": jurisdictions,
    }


@router.get("/{code}")
async def get_jurisdiction(
    code: str,
    include_relations: bool = Query(False, description="Include related incentiveRules and productions"),
) -> Dict[str, Any]:
    code = str(code).strip().upper()
    if not code:
        raise HTTPException(status_code=400, detail="Code is required")

    kwargs: Dict[str, Any] = {"where": {"code": code}}
    if include_relations:
        kwargs["include"] = {"incentiveRules": True, "productions": True}

    j = await prisma.jurisdiction.find_unique(**kwargs)
    if not j:
        raise HTTPException(status_code=404, detail=f"Jurisdiction not found: {code}")

    item = _to_jurisdiction_dict(j)
    if include_relations:
        rules = getattr(j, "incentiveRules", None) or []
        prods = getattr(j, "productions", None) or []
        item["incentiveRules"] = [_to_rule_dict(r) for r in rules]
        item["productions"] = [_to_production_dict(p) for p in prods]

    return {"jurisdiction": item, "include_relations": include_relations}
